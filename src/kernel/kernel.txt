线程栈在堆空间


设备节点可以用mknode手动创建，也可以使用mdev(udev)自动创建内核中定义struct class

1 编译
  clean           - Remove most generated files but keep the config and
                    enough build support to build external modules
  mrproper        - Remove all generated files + config + various backup files
  distclean       - mrproper + remove editor backup and patch files(distribution)



注：
mrproper这个诡异的名字是什么意思呢? Wiki页 http://en.wikipedia.org/wiki/Mr._Clean提到：
"make mrproper" is a command in the Linux kernel build system, used to "clean up" 
all files from past builds and restore the build directory to its original clean state. 
The reason "make mrproper" is used instead of "make mrclean" is because Linus Torvalds, 
the father of Linux, was familiar with the name "Mr. Proper" as this is the brand 
widely known in Europe."
意思是说：Mr.Proper在欧洲是一个清洁产品的商标，Linux借用这个词表示彻底清除编辑记录。

1 20140726
首次执行：
make xx_default_config

将scripts/kconfig 下的c代码编译为 conf 程序

直接执行 make xxx 提示：
make: *** No rule to make target `xxx'.  Stop. 这是Make自己提示的.
xx_default_config是一个目标，定义在

scripts/kconfig/Makefile :

%_defconfig: $(obj)/conf
        $(Q)$< -D arch/$(SRCARCH)/configs/$@ $(Kconfig)



------------------



0  vmlinux,vm代表“Virtual Memory”。Linux 支持虚拟内存，支持mmu，不像DOS有640KB内存的限制

显示内核打印信息：cat /proc/kmsg &   或者用dmesg命令
内核信息打印有七个日志级别，数字越低，级别越高

1-1.3:1.0的意思是，摄像头使用的根集线器编号为1，集线器端口号为1，集线器（摄像头使用）端口号为3，配置为1，接口为0

UVC是在linux-2.6.38版本时加入内核的

Documentation/video4linux/uvcvideo.txt”中，是有关于UVC的说明。驱动源码位置：./media/video/uvc/。

1 kernel控制台

kernel 控制台可以用fb显示。
gwb调通了recovery里面用fb显示console内容的部分。
recovery使用的是自己带的字库，实际上，kernel里面 drivers/video/console 里面也有字库用于fb显示console

要理解 console 主设备5 次设备1 关注 drivers/char/tty_io.c 文件

major.h 中定义
#define TTYAUX_MAJOR  5

device_create(tty_class, NULL, MKDEV(TTYAUX_MAJOR, 1), NULL,"console");

/dev/console  5 1
/dev/tty      5 0
/dev/ptmx     5 2
/dev/ttyprintk 5 3


/dev/tty0     4 0
/dev/tty1     4 1

/dev/ttyS0    4 64
/dev/ttyS1    4 65

关于 tty  console   std_in std_out  std_err 的关系还不是很清楚

2
1 arch/arm/kernel/traps.c 中

static int __die() 里面

printk(KERN_EMERG "Process %.*s (pid: %d, stack limit = 0x%p)\n",TASK_COMM_LEN, tsk->comm, task_pid_nr(tsk), thread + 1);

看一个打印信息：

Process Binder Thread # (pid: 1043, stack limit = 0xd9a942f8 )  //这里看出 2 page的内核栈开始地址 0xd9a94000  thread结构体的大小为 0x2f8 
stack limit 意思是 栈不能超过这个地址。
下面：
Stack: (0xd9a95df4 to 0xd9a96000)   这里的开始地址是由上面的 sp: d9a95df4 决定的。
5de0:.....
.....

	if (in_interrupt())
		panic("Fatal exception in interrupt");
	if (panic_on_oops)    // oops错误的时候，打印 Kernel panic - not syncing: Fatal exception
		panic("Fatal exception");

panic()函数里面
printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);


Kernel hacking 里面ARM_UNWIND  配置，Enable stack unwinding support  （unwind 松开，解开）

意思是显示函数调用关系。 这需要 栈帧（我之前已经理解了这个）
内核中还有CONFIG_FRAME_POINTER  配置，但是

CONFIG_ARM_UNWIND
This option enables stack unwinding support in the kernel
using the information automatically generated by the
compiler. The resulting kernel image is slightly bigger but
the performance is not affected. Currently, this feature
only works with EABI compilers. If unsure say Y. 


CONFIG_FRAME_POINTER
Compile the kernel with frame pointers


debugfs 是个什么东西？


-----------------------
20111226 printk系统
1 nxp平台经常出现 evbug.c: Event. Dev: input1, Type: 0, Code: 0, Value: 0 打印，封闭开发的时候就又
实际上，这个不是crash，而是正常的打印，调试input的，正常下这个debug模块应该关闭，（海思平台就是关闭的）
打开后，应该一直有打印的，只不过：
static void evbug_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)
{
	printk(KERN_DEBUG "evbug.c: Event. Dev: %s, Type: %d, Code: %d, Value: %d\n",
		dev_name(&handle->dev->dev), type, code, value);
}

注意，打印级别为 KERN_DEBUG ，正常没有打印出来，那么为什么nxp dvb 异常情况会打印呢？顾文彪猜测是异常的时候，系统改变了打印级别（目前没有证据）

2 关注一下 kenel/sysctl.c这个文件 用来生成 /proc/sys/kernel 项的
cat /proc/sys/kernel  打印一般是 7 4 1 7 什么意思呢？


==============================================================
printk:
The four values in printk denote: console_loglevel, default_message_loglevel, minimum_console_loglevel and default_console_loglevel respectively.
These values influence printk() behavior when printing or logging error messages. See 'man 2 syslog' for more info on the different loglevels.
- console_loglevel: messages with a higher priority than this will be printed to the console
- default_message_level: messages without an explicit priority will be printed with this priority
- minimum_console_loglevel: minimum (highest) value to which console_loglevel can be set
- default_console_loglevel: default value for console_loglevel
==============================================================


3 根目录Makefile里include $(srctree)/arch/$(SRCARCH)/Makefile
在arch/arm/Makefile中有：

boot := arch/arm/boot
./scripts/Kbuild.include:
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj

zImage Image xipImage bootpImage uImage: vmlinux
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
这里组合完，出现了  obj=$(boot) 的效果，$(boot)/$@ 在 Makefile.build中用 $(1)引用

可见，编译zImage 要先编译vmlinux  然后会编译boot目录下的内容
在内核编译完成后会在arch/arm/boot/下生成zImage

在arch/arm/boot/Makefile中：

$(obj)/zImage:　$(obj)/compressed/vmlinux FORCE
　　　　　　　 $(call if_changed,objcopy)

由此可见，zImage的是elf格式的arch/arm/boot/compressed/vmlinux二进制化得到的

在arch/arm/boot/compressed/Makefile中：

$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o
　　　 　　　　　　　　　　　　　 　　　　　　　　　　 $(addprefix $(obj)/, $(OBJS)) FORCE
　　　 　　　 $(call if_changed,ld)
$(obj)/piggy.gz: $(obj)/../Image FORCE
　　　 　　　 $(call if_changed,gzip)
$(obj)/piggy.o:　$(obj)/piggy.gz FORCE


其中Image是由内核顶层目录下的vmlinux二进制化后得到的。
注意：arch/arm/boot/compressed/vmlinux 是位置无关的，这个有助于理解后面的代码。
链接选项中有个 –fpic参数：

　　EXTRA_CFLAGS　:= -fpic

总结一下zImage的组成，它是由一个压缩后的内核piggy.o，连接上一段初始化及解压功能的代码
（head.o misc.o）组成的。

下面就要看内核的启动了，那么内核是从什么地方开始运行的呢？这个当然要看lds文件。
zImage的生成经历了两次大的链接过程：一次是顶层 vmlinux的生成，由arch/arm/boot/vmlinux.lds
（这个lds文件是由arch/arm/kernel /vmlinux.lds.S生成的）决定；另一次是arch/arm/boot/compressed/vmlinux的生成，
是由arch/arm /boot/compressed/vmlinux.lds（这个lds文件是由arch/arm/boot/compressed /vmlinux.lds.in生成的）决定。
zImage的入口点应该由arch/arm/boot/compressed/vmlinux.lds决定。从中可以看出入口点为‘_start’

OUTPUT_ARCH(arm)
ENTRY(_start)
SECTIONS
{
　 . = 0;
　_text = .;
　.text : {
　　_start = .;
　　*(.start)
　　*(.text)
　　　　　　　　　　 ……
}

　　在arch/arm/boot/compressed /head.S中找到入口点.。

看看head.S会做些什么样的工作：

对于各种Arm CPU的DEBUG输出设定，通过定义宏来统一操作；
设置kernel开始和结束地址，保存architecture ID；
如果在ARM2以上的CPU中，用的是普通用户模式，则升到超级用户模式，然后关中断
分析LC0结构delta offset，判断是否需要重载内核地址(r0存入偏移量，判断r0是否为零)。
需要重载内核地址，将r0的偏移量加到BSS region和GOT table中的每一项。对于位置无关的代码，
程序是通过GOT表访问全局数据目标的，也就是说GOT表中中记录的是全局数据目标的绝对地址，
所以其中的每一项也需要重载。
清空bss堆栈空间r2－r3
建立C程序运行需要的缓存
这时r2是缓存的结束地址，r4是kernel的最后执行地址，r5是kernel境象文件的开始地址


用文件misc.c的函数decompress_kernel()，解压内核于缓存结束的地方(r2地址之后)。
可能大家看了上面的文字描述还是不清楚解压的动态过程。还是先用图表的方式描述下
代码的搬运解压过程。然后再针对中间的一些关键过程阐述。
假定zImage在内存中的初始地址为0x30008000(这个地址由bootloader决定，位置不固定)1、初始状态

.text	0x30008000 开始，包含piggydata段（即压缩的内核段）
. got	
. data	
.bss	
.stack	4K 大小

　　2、head.S调用misc.c中的decompress_kernel刚解压完内核后　

.text	0x30008000开始，包含 piggydata段（即压缩的内核段）
. got	
. data	
.bss	
.stack	4K 大小
解压函数所需缓冲区	64K大小
解压后的内核代码	小于4M

　　3、此时会将head.S中的部分代码重定位

.text	0x30008000 开始，包含piggydata段（即压缩的内核段）
. got	
. data	
.bss	
.stack	4K 大小
解压函数所需缓冲区	64K大小
解压后的内核代码	小于4M
head.S中的部分重定位代码代码	reloc_start至reloc_end

　　4、跳转到重定位后的reloc_start处，由reloc_start至reloc_end的代码复制解压后的内核代码到0x30008000处，并调用call_kernel跳转到0x30008000处执行。

解压后的内核	0x30008000 开始

　　在通过head.S了解了动态过程后，大家可能会有几个问题：

　　问题1：zImage是如何知道自己最后的运行地址是0x30008000的？问题2：调用decompress_kernel函数时，其4个参数是什么值及物理含义？问题3：解压函数是如何确定代码中压缩内核位置的？　

　　先回答第1个问题

　　这个地址的确定和 Makefile和链接脚本有关，在arch/arm/Makefile文件中的textaddr-y　　:= 0xC0008000 　　这个是内核启动的虚拟地址TEXTADDR := $(textaddr-y)　　　 在arch/arm/mach-s3c2410/Makefile.boot中zreladdr-y　　 := 0x30008000　　 这个就是zImage的运行地址了在arch/arm/boot/Makefile文件中　ZRELADDR　　:= $(zreladdr-y)在arch/arm/boot/compressed/Makefile文件中zreladdr=$(ZRELADDR) 　　　　　在arch/arm/boot/compressed/Makefile中有　　　 　　　　　　　.word　　　zreladdr　　　　@ r4　　　 内核就是用这种方式让代码知道最终运行的位置的　

　　接下来再回答第2个问题

　　decompress_kernel(ulg output_start, ulg free_mem_ptr_p, ulg free_mem_ptr_end_p,　　　　　　　　int arch_id)l　　　　 output_start：指解压后内核输出的起始位置，此时它的值参考上面的图表，紧接在解压缓冲区后；l　　　　 free_mem_ptr_p：解压函数需要的内存缓冲开始地址；l　　　　 ulg free_mem_ptr_end_p：解压函数需要的内存缓冲结束地址，共64K；l　　　　 arch_id ：architecture ID，对于SMDK2410这个值为193；　

　　最后回答第3个问题

　　首先看看piggy.o是如何生成的，在 arch/arm/boot/compressed/Makefie中　　　　$(obj)/piggy.o:　$(obj)/piggy.gz FORCE　　　　　　　　　　　　　　　　　　　　　 Piggy.o是由piggy.S生成的，咱们看看piggy.S的内容：　　　 .section .piggydata,#alloc
　　　 .globl　　　input_data
input_data:
　　　 .incbin　　"arch/arm/boot/compressed/piggy.gz"
　　　 .globl　　　input_data_end
input_data_end:

　　再看看misc.c中 decompress_kernel函数吧，它将调用gunzip()解压内核。gunzip()在lib/inflate.c中定义，它将调用 NEXTBYTE()，进而调用get_byte()来获取压缩内核代码。

　　在misc.c中#define get_byte()　(inptr < insize ? inbuf[inptr++] : fill_inbuf())查看 fill_inbuf函数int fill_inbuf(void)
{
　　　 if (insize != 0)
　　　　　　　error("ran out of input data");
　　　 inbuf = input_data;
　　　 insize = &input_data_end[0] - &input_data[0];
　　　 inptr = 1;
　　　 return inbuf[0];
}发现什么没？这里的input_data不正是piggy.S里的input_data 吗？这个时候应该明白内核是怎样确定piggy.gz在zImage中的位置了吧。时间关系，可能叙述的不够详细，大家可以集合内核代码和网上的其它相关文章，理解启动解压过程。






 * misc.c 
 * This is a collection of several routines from gzip-1.0.3 
 * adapted for Linux.

在arch arm Makefile中：
define archhelp
  echo  '* xipImage      - XIP kernel image, if configured (arch/$(ARCH)/boot/xipImage)'
  echo  '  uImage        - U-Boot wrapped zImage'
  echo  '  bootpImage    - Combined zImage and initial RAM disk' 
  echo  '                  (supply initrd image via make variable INITRD=<path>)'
  echo  '  install       - Install uncompressed kernel'
  echo  '  zinstall      - Install compressed kernel'
  echo  '                  Install using (your) ~/bin/installkernel or'
  echo  '                  (distribution) /sbin/installkernel or'
  echo  '                  install to $$(INSTALL_PATH) and run lilo'
endef


noinitrd console=ttyS1,115200n8 mtdparts=nx_2016:1536k@0k(boot),5m@1536k(kernel),32m@7m(root),32m@39m(appfs),-(extra);nx_sfc:1536k@0k(boot),5m@1536k(kernel),8m@7m(root),-(sfc-extra) root=/dev/nfs nfsroot=192.168.1.201:/home/gaojie/nfsroot/ rw ip=dhcp


  zImage Compressed kernel image (arch/$(ARCH)/boot/zImage)
  Image  Uncompressed kernel image (arch/$(ARCH)/boot/Image) 这两个都是能够自启动的
  uImage U-Boot wrapped zImage (zImage加上64字节 u-boot头)
  zImage的组成：压缩后的内核piggy.o连接上一段初始化及解压功能的代码（head.o misc.o）

14 启动内核时，使用bin文件(go addr) 和elf文件(booelf)的时候不检测bootargs参数，使用内核自带编译进入的参数
   只有使用bootm(u-boot uImage)时候使用这个参数替代内核内部参数

注意：直接make vmlinux 不会生成log的ko文件 需要执行make modules
如果只输入make 会执行all：目标，即makefile中的第一个目标，应该会生成所有包括vmlinux uImage zImage modules 呵呵

主要考察 arch/arm/Makefile 和 arch/arm/boot/Makefile

----------
kernel中的 mkuboot.sh
#!/bin/bash
# Build U-Boot image when `mkimage' tool is available.

if [ -z ${MKUIMAGE}  ];then
MKUIMAGE=$(type -path "${CROSS_COMPILE}mkimage")
fi
if [ -z "${MKUIMAGE}" ]; then
	MKUIMAGE=$(type -path mkimage)
	if [ -z "${MKUIMAGE}" ]; then
		# Doesn't exist
		echo '"mkimage" command not found - U-Boot images will not be built' >&2
		exit 0;
	fi
fi
# Call "mkimage" to create U-Boot image
${MKUIMAGE} "$@"





分区：
struct mtd_partition

make distclean
make clean


---
除了拆开盒子，如何迅速查出板子内存配置



fcntl.h定义了很多宏和open,fcntl函数原型  #include <unistd.h>
　　是POSIX标准定义的unix类系统定义符号常量的头文件，包含了许多UNIX系统服务的函数原型，例如read函数、write函数和getpid函数

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

 mode specifies the permissions to use in case a new file is created.  
这里的权限就指 用户，组，其他的读写可执行等
只有指定 O_CREAT 参数的时候，mode才有意义，否则直接赋值为0即可，即使不赋0，内部也会把他清零。


1 epoll - I/O event notification facility
epoll 是 poll 的变体

epoll是Linux内核为处理大批量句柄而作了改进的poll，是Linux下多路复用IO接
口select/poll的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的
情况下的系统CPU利用率。

select/poll 叫 多路复用i/o接口？!


堆栈回溯
typedef struct frame_pointer_t
{
    struct frame_pointer_t *pre;
    unsigned int    ret_address;
}frame_pointer;

static frame_pointer* fp;
void stack_trace(int n)
{

    __asm("sw  $30, fp"); 
    while(n--)
    {
       dl_printf("\r\n frame is 0x%x, ret address is 0x%x \r\n", (unsigned int)fp->pre, fp->ret_address);
       fp = fp->pre;
    }
}


20131023 调试EPG系统引发
编译完成了如何安装到服务器，如何制作安装包
新的so放入到/usr/local/lib 下要运行 ldconfig 才能找到。


针对不同的平台，要移植irq.c 
他干什么呢？ 要处理一级中断。

这里要注册中断号码。基本是按照一级中断寄存器定义的。

irq.c 主要是实现一个 struct irq_chip 结构体


1 malloc 分配堆空间，mm_struct记录brk地址  那么程序malloc 后再free 那么堆空间起步就出来一个空洞？这时候再malloc 还是要继续扩充brk吗？
2 malloc 8k 然后memset 3byte 内核会一次分配出来8k物理内存吗？

关于malloc分配器：有的地方用大车，有得地方用小车
火车把一批人运送到一个城市，再由小车运送到各个地方。个有个的用处。
就像buddy系统和malloc分批器的区别一样。

就好比我从这里做地铁到回龙观，再做个摸底到家里。
如果我从这里就打个摸底到家，那轮子还不得开掉了。


