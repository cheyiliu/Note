1 基本命令 
	1) pull
		pull = fetch + merge
		pull不看同名看track，“当前分支”有track关系时，git pull做合并操作。
		当前不在这个分支时，这个分支虽然有track关系，也只是fetch不merge
		另一种执行方式为：git pull origin newbox

	2) 参数
		-f --force
		用在各个命令中  add 可以添加被.gitignore忽略的文件

	3) 本地与远程同名分支才能互相合并跟踪
	4) push:Updates remote refs using local refs
	5) git help -w commit  打开html帮助信息

git config --list  检查已有配置项
git config user.name 检查特定配置项的值

个性化git例如
　　[user]
　　name = Phoenix
　　[alias]
　　co = checkout
　　ci = commit -a
　　st = status
　　br = branch
　　oneline = log --pretty=oneline --since='2 days ago'
　　onelog = log -p -1

一个仓库维护多个项目的问题：
1 建立分支
2 配置文件shell拷贝

即使没有track关系（即.git/config里面没有类似下面的描述）
[branch "xxx"]
  remote = origin
  merge = refs/heads/xxx
只要是同名分支，都会被跟踪track，git push 无参数都可以push。


 1 当前分支无跟踪分支时，执行git pull提示：

You asked me to pull without telling me which branch you
want to merge with, and 'branch.newbox.merge' in
your configuration file does not tell me, either. Please
specify which branch you want to use on the command line and
try again (e.g. 'git pull <repository> <refspec>').
See git-pull(1) for details.

If you often merge with the same branch, you may want to
use something like the following in your configuration file:

    [branch "newbox"]
    remote = <nickname>
    merge = <remote-ref>

    [remote "<nickname>"]
    url = <url>
    fetch = <refspec>

See git-config(1) for details.



2 git config

	--system选项创建并操作/etc/gitconfig针对所有用户
	--global选项创建并操作~/.gitconfig针对当前用户
	无选项操作.git/config针对当前项目	
	后面的会覆盖前级同名配置，例如.git/config覆盖/etc/gitconfig中同名变量

	git config --global core.editor vim
	git config --global user.name "xx"
	git config --global user.email xx@xx.com
	git config --global merge.tool vimdiff

	Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。


 branch.autosetupmerge
 Tells git branch and git checkout to set up new branches so that git-pull(1) will 
appropriately merge from the starting point branch. Note that even if this
 option is not set, this behavior can be chosen per-branch using the --track and 
--no-track options. 
The valid settings are: false — no automatic setup is done;
 true — automatic setup is done when the starting point is a remote branch; always
 — automatic setup is done when the starting point is either a local branch or 
remote branch. This option defaults to true.

Delta压缩算法：两文件相似性超过预设阀值时，仅存储计算出的Delta编码。在存储具有相似性的文件时，此方式可减少空间。 

如果.git/refs/remotes/下面只有一个目录 就不需要指定参数 直接git fetch 即可 并且这个
m目录在remote目录中显示 ref: refs/remotes/vc/fawn

也就是说他只是简单指向我用的另外一个远程仓库。那建立这个的作用是什么呢？ git_refs.py 
定义 R_M     = 'refs/remotes/m/'


在framework/base中 执行了git pull url 结果把仓库搞坏了，执行git checkout -f 强制切
换到其他分支 再git fetch 才好。

直接执行 git pull 提示：fatal: Where do you want to fetch from today?

注意：我先git checkout ngb/newbox 再 git pull  ngb omx-dev-zzq-new 结果把
omx-dev-zzq-new分支合并到了newbox了！


3 git-rm - Remove files from the working tree and from the index
  实验发现，git rm 后 index文件发生变化，index最开头有一个字段记录文件总数，后面是相
应的文件路径和名字。那么跟直接从working tree中删除有什么区别呢？
  Remove files from the index, or from the working tree and the index.（还可以只
删除index 不删除working tree）
  --cached
  Use this option to unstage and remove paths only from the index. Working tree 
files, whether modified or not, will be left alone.

-f, --force
Usually, the command refuses to update a remote ref that is not an
ancestor of the local ref used to overwrite it. This flag disables
the check. This can cause the remote repository to lose commits;
use it with care.
一般情况下，push之前如果某个分支别人有提交，是push不上去的，需要先pull合并再
push，加上-f后不检测，直接提交，会导致远程仓库丢失若干提交。要谨慎使用此选项。

5 git-receive-pack - Receive what is pushed into the repository

7 git-show-ref  git-show-ref - List references in a local repository
 就是把.git/refs目录中的东西list一遍

8 fetch = +refs/heads/*:refs/remotes/ngb/* 是否表示fetch的时候下载refs/heads 和 
refs/remotes/ngb目录的所有东西？ 那么，refs/heads表示本地分支名，为什呢我不能把别人
的本地分支下载下来呢？
可能是因为，大家提交的时候没有把本地分支提交上去。
git push --all 
--all
Instead of naming each ref to push, specifies that all refs under refs/heads/ be pushed.

git push --mirror 好像把base仓库搞坏了，把refs/heads里面的分支，也就是本地分支　push
到了远程，而远程原来的分支全部被删除了。
注：好像是refs/heads　里面有哪几个分支就保留哪个分支，其他的远程分支全部删除。本地分
支怎么提交到服务器啊


To always push all branches and tags, you can update .git/config  like so:

[remote "origin"]
  url = ...
  fetch = ...
  push = +refs/heads/*
  push = +refs/tags/*

That will make a normal push similar to a mirror, except that it won't delete 
branches that don't 
exist at the source or for non-fast-forward updates.

I usually use git push --all. I only use --mirror when i need to push newly created 
branches or I deleted some branches and dont want to name them one by one. Otherwise 
the push --all usually works as I need.

执行git push --mirror 可能会损坏仓库。

把修改变化从本地分支推入远程版本库
git push <remote repository> <local branch>:<remote branch>

把修改变化从本地分支推入远程分支版本库中同名分支
git push <remote repository> <local branch>

把修改变化推入别名为 origin 的远程版本库
git push

在远程版本库中删除分支
git push <remote repository> :<remote branch>

2011-03-01 04:10 framework/base终于恢复。 步骤：
a 我在好的目录中，把所有的远程分支全部创建一遍本地分支，然后git push --mirror
b 在我这里再删除base目录，同时删除.repo里面的base.git[可能是这个操作起了作用吧！不知
道是这个还是上一个步骤，晕了]

9 git clone  framework/base仓库 出现一个 packed-refs  在refs目录里面没有更多的内容 
这点跟android里面的这个相应仓库不同，那里 refs目录里面单个的文件

10　描述一种情景：我在framework/base

11 git-pack-refs - Pack heads and tags for efficient repository access
Traditionally, tips of branches and tags (collectively known as refs) were stored one 
file per ref under $GIT_DIR/refs directory. While many branch tips tend to be updated 
often, most tags and some branch tips are never updated. When a repository has hundreds 
or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.

git pack-refs refs/heads下面的本地分支就都消失了，进入packed-refs 文件中


14 注意：git push --mirror 是使用ref/heads里面的branch更新远程的分支。
   push --all
   Instead of naming each ref to push, specifies that all refs under refs/heads/ be pushed.
   push /refs/heads下面的分支，但是此目录下没有的分支也不会在远程删除。而mirror则会！害死我了这个参数。
   可以确定的是mirror 只把ref/heads里面的分支提交上去，远程的其他分支会被删除，并且在本地执行了push --mirror后
   本地仓库立刻变成远程仓库的样子【可怕】。因为本地分支没有提交到远程，所以每个人的本地目录的本地分支都不同。


15 猜测：git的服务端应该没有 ref/heads目录吧，因为他不需要本地分支。也可能有，因为如果把本地分支提交上去
   需要确认：本地分支能push上去吗？

16  git clone --mirror
17  ~/.gitconfig
    

19 *网络上的一段讨论*
Git: how to unpack packed-refs?
Hi.
I cloned a project from github with git clone --mirror. That left me with a repository 
with a packed-refs file, a .pack and an .idx file. For developement purposes I want 
to look at the loose objects, so I unpacked the objects with git unpack-objects
 < <pack file> which worked fine (I unpacked the pack file into a new repo if 
you're wondering). Only thing is that refs/heads/ is still empty, all the refs 
are still only in packed-refs but I need them in refs/heads/. I wasn't able to 
find a command that would extract or unpack those references and I can somehow
 not believe that I would have to do this by hand (or via pipes).

So actually I have two questions:

   1. Is there an easy way to "restore" refs from packed-refs?
   2. If not, why isn't there? If there's a command for unpacking objects, what 
is the reasoning behind not providing the same for refs (don't forget that there's 
even a command git pack-refs...)

Thanks for any tips and ideas.

The short answer is "no" - there is no "easy way" to unpack the refs the way you're 
asking.
The reason the packed refs exist is to speed up access in a repo with zillions of 
refs - it's easier to look at a single file with many lines than to hit the file 
system once for every single ref. Anything in git which needs to know about refs 
goes through code which can read both the refs directory and the packed refs file. 
Unpacking it would defeat its purpose. If you want to access refs, use the plumbing 
commands (e.g. show-ref, for-each-ref, update-ref...). I can't really think of any 
kind of access which would be faster and easier with the directory structure than 
with the plumbing commands (especially with for-each-ref available).
And yes, packed objects are (like packed refs) created for improved performance, 
but there's a huge difference. A packed refs file is just a bunch of independent 
lines. You can, essentially for free, add to or remove from it. There's no need 
to unpack it in order to modify it. Packed objects, on the other hand, are 
delta-compressed, so the objects inside depend on each other. They greatly reduce
 disk usage, and objects can be read from them at reasonable cost, but attempting 
to modify the set of objects in the pack is much more expensive than modifying 
loose objects, so it's only done periodically by git repack (called by git gc),
 though I don't believe git repack actually unpacks the objects - it just reads
 them from the packfile, packs them with the loose ones, and makes a new pack.
However, when a pack is transferred from a remote, it's unpacked on the local 
side. I see a call to an unpack method in the git receive-pack source, and the
 pack-objects manpage says:
    The git unpack-objects command can read the packed archive and expand the 
objects contained in the pack into "one-file one-object" format; this is typically
 done by the smart-pull commands when a pack is created on-the-fly for efficient
 network transport by their peers.


21 git push [--all | --mirror | --tags]
   --all 是把refs/heads/里面的分支全部push上去
   --tags 是把refs/tags全部push上去，当然可以同时--tags --all ，
       All refs under refs/tags are pushed, in addition to refspecs explicitly listed on the command line.【我懂的】
   --mirror是把本地的/refs/heads  refs/tags 里面的东西push上，这里没有，远程有的，就被删除
   总之，没有任何方法能够把本地分支的标签push上去以便别人pull后自动下载若干本地标签。我当时用mirror就是想把本地分支标签push上去。
    mirror参数会提交本地tags，删除本地没有的远程tags，提交本地的分支到远程，删除本地没有的远程分支


23 理解refs了,tag不动，分支名会动
   当我切换到一个远程分支的时候 如git checkout ngb/newbox 会提示：
$ git checkout origin/gaojie
Note: checking out 'origin/gaojie'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

看意思，这个状态可以修改，提交(但是通过实验好像不能push到远程)。所以上面说可以look around,experiment
change and commit。但是只要以后执行分支切换这个修改就会被覆盖，并且不能被永远覆盖，不能恢复了【实验证明了】。
所以这种状态就是一种临时状态，可以看代码，修改实验，但是不能永久保存跟不能提交
这个时候要创建新的本地分支 只需git checkout -b new_branch  而不用git checkout -b new_branch origin/xxx
在这种状态下commit，分支标签不向前移动。但是HEAD里面的SHA值会变化。

24 2011-03-03 刚才突然发现，git pull 还有些疑问
  看看fetch的格式吧：
       git fetch <options> <repository> <refspec>...
       git fetch <options> <group>
       git fetch --multiple <options> [<repository> | <group>]...
       git fetch --all <options>

我把framework/base 单独clone下来 只有一个origin  这时可以直接git fetch 不加任何参数
而在android里面的base仓库 有一个ngb 还有一个 m  直接git fetch 没参数的话会提示：
fatal: Where do you want to fetch from today?

(20111214)但是tab键会出来 ngb 因为config文件里面只有 [remote "ngb"] 

25 git://git.kernel.org/pub/scm/git/git.git 是git的源代码的git
   我现在用的是v1.7.0.4 所以先git checkout v1.7.0.4 (这是一个tags)
   wget http://kernel.org/pub/software/scm/git/git-1.7.1.tar.gz
或者wget http://kernel.org/pub/software/scm/git/git-1.7.0.4.tar.gz
唯一的区别是后者有configure    那么git checkout出来的怎么编译呢？
然后
./configure --prefix=/usr
 make  && make install
builtin-fetch.c中  cmd_fetch
builtin_fetch_options 就指执行git fetch 时候加的option  即-或者--开头的字符串。

if (all) {	
	if (argc == 1)
		die("fetch --all does not take a repository argument");
	else if (argc > 1)
		die("fetch --all does not make sense with refspecs");
如果执行 git fetch --all origin 就会打印：
fetch --all does not take a repository argument
git fetch --all 后 all变量就为1

} else if (argc == 0) {
	/* No arguments -- use default remote */
	remote = remote_get(NULL);
	result = fetch_one(remote, argc, argv);
}
直接执行git fetch 不加任何参数，走这里
remote_get 当只有一个remote的时候，argc==0的是返回非空，当有多个remote时候，就返回0了.这时就会提示：Where do you want to fetch from today？

26 看看这个提示：
You are not currently on a branch, so I cannot use any
'branch.<branchname>.merge' in your configuration file.
Please specify which remote branch you want to use on the command
line and try again (e.g. 'git pull <repository> <refspec>').
See git-pull(1) for details.

27 我一直没有机会看到git服务器上的文件夹结构，但是能够看到kernel.org上git源码的git仓库
  目录名git.git[git管理git^_^], 这个目录的内容相当于.git中的内容。需要注意refs目录。
  里面只有heads和tags，没有remote。因为他就是remote，所以没有remote。heads里面的内容
  我git clone后就变成本地的refs/remote。这也说明了 refspec参数：
  fetch = +refs/heads/*:refs/remotes/origin/*  前面是源，是远程的 后面是目的，是本地的。
  当然，这个仓库还可以有远程仓库，比如现在的ngb仓库，既是服务端，同时还可以从google同步，这时又成为本地端。

29 git remote add  name  url  后，需要git fetch --all 才能在本地建立相应目录。难道执行git remote add命令
  的时候，需要向远程添加文件吗？可以断开网线试试：

 好像理解git remote的含义了。他可以管理多个仓库，比如在github的仓库中执行：
 git remote add bionic git://android.git.kernel.org/platform/bionic.git
 并且如果使用 git remote rename 把默认的 origin 名字改为其他，这个只是本地操作，不会对服务器造成任何影响。
 并且服务器也根本不曾有origin这个名字，只是git默认创建的一个名字而已
 最终总结处的结论：可以直接git fetch 不提示Where do you want to fetch from today的情况
 1 只有一个origin 2 只有一个其他任何xx 的remote名 3 有一个origin 和另外一个xx 的remote
 我用github测试 git remote add  和 git remote rm 可以删除一个remote
 但是ngb的名为m 的remote 无法用git remote rm 删除。这个名为m remtoe比较特殊，在config 文件中没有描述。

 ngb的仓库比如framework/base 中的m 直接在refs/remote/中删除即可，在gitg中就看不到了，这是只剩下一个叫ngb的
 remote，但是奇怪的是此时git fetch 仍然提示 here do you want to fetch from today
 这时，把ngb rename成 origin 就可以直接git fetch了，有意思。
[20110314批注：因为默认仓库是origin并不以个数论]

30 为什么ngb的项目repo下来的remote名字叫做ngb，而clone下来的就叫做origin呢？
   这是manifest在捣鬼。今天才发现至于名为m的remote，原始的android仓库就有，并不是x搞出来的
   原来的remote叫做 korg 和 m，xxx改成了ngb和m

31 2011-03-04 再次考虑一下repo这个python问题。
   ./repo help 
   Switching Manifest Branches
---------------------------
To switch to another manifest branch, `repo init -b otherbranch` may be
used in an existing client. However, as this only updates the manifest,
a subsequent `repo sync` (or `repo sync -d`) is necessary to update the
working directory files.

 -b REVISION, --manifest-branch=REVISION manifest branch or revision
 -m NAME.xml, --manifest-name=NAME.xml initial manifest file
[一直没有搞懂froyo的manifest里除了default还有很多其他的，怎么用，现在清楚了]


32 2011-03-04 祁智恒说，moto公司git的用法：每一个模块或者功能作为一个分支，最后出版本的时候

33 再看git push [<repository> <refspec>...]
  <repository>
  The "remote" repository that is destination of a push operation.
  This parameter can be either a URL (see the section GIT URLS below)
  or the name of a remote (see the section REMOTES below).
此参数可以是一个地址，也可以是一个remote名字【remote名字是一个“本地行为”我懂的】
但是有必要指定这个吗？难道还能把这个仓库的修改推送到别的仓库?

在github上测试，有2个远程分支对应的本地分支都发生了修改，执行git push 无参数，可以同时
把2个分支都推送上去。 但是如果一个新建的本地分支，还没有远程的分支与之对应【这里的“对应”其实是指具有track关系】

如果建立一个新的本地分支（远程还没有对分支），执行git push 无参数，这个分支是推不上去的。只能执行 ”git push origin 本地分支名“ ，才行
【重点】：但是，git push origin test 

可以从一个标签处开始工作 Start development from a known tag
git branch my2.6.14 v2.6.14
git checkout my2.6.14  合二为一如下：
checkout -b my2.6.14 v2.6.14  【当然】这个分支是一个独立分支，不是跟踪分支
没有一个远程分支跟他对应，当然不能跟踪，在.git/config里面没有相应记录
修改后，直接git push 无参数 这个分支是提交不上去的！而此操作只能提交有跟踪关系的分支，
并且在github上测试，不论当前在哪个分支，即使在一个独立分支里面，此命令仍然可以把多个有
修改的跟踪分支一 一提交上去。

如果不写repo参数，默认是【origin】

34 git-rev-parse 是干啥用的

35 2011-03-05 0:55  关于 冲突 的理解
  我一位全部理解了，其实还没有，今天，不昨天，就遇到了一件有意思的事情：
  在把baseplatform分支往newbox分支合并的时候出现冲突【具体情况不用理会】，
  分析：
	假设一文件代码如下：
	i=5；
	i=6；
	i=7；
	然后以此为基础，产生2个分支，第一个分支a没有修改这个文件，第二个分支b删除了i=6；
	得出结论：b向a合并，没有conflict【[英] [ˈkɔnflikt]  [美] [ˈkɑnˌflɪkt] 】
		a分支也会删除此行，但是a向b合并会冲突，因为系统不知道i=6是删除还是恢复。
	当时觉得很有道理，并且开始怀疑baseplatform分支的作用，认为此分支已经不可能合并
	到newbox，因为newbox有很多处删除代码操作，而baseplatform还保留这些代码，合并
	的时候就会有conflict。
	但是用github测试发现a向b合并根本不会冲突，会保持b的删除状态！
	仔细想想也有道理，b改了，同样地方a没有动（a人员根本就没有“关注”这个地方），当然要
	保持b的修改。注意，分析是否conflict的时候，一是要跟分叉点对比，二是要看作者有没
	有“关注”这块代码！
	
	所以baseplatform分支还是可以用的，也可以想newbox分支合并！

	注意:2个分支，“改”了同一个地方，才会有冲突，一个改，一个没改不会有冲突。

看看这个冲突：

++<<<<<<< HEAD
++=======
+ import android.view.MotionEvent;
+ import android.view.View;
++>>>>>>> base-platform

我就是看到这个才以为上面那个例子成立的，按现在的理解这种情况不应该冲突啊！
实际情况是：
原始文件(祖先)：
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.ViewGroup;

HEAD文件：A

import android.util.AttributeSet;
import android.view.ViewGroup;

base-platform：B

import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;

这时候合并才出现了上面的冲突，
如果祖先文件是：
原始文件(祖先)：
import android.util.AttributeSet;
import android.view.ViewGroup;

那么，就没有冲突：A向B合并，B保持不变，B向A合并，增加中间两行！

重要理解：
必须找到2个分支的共同“纯祖先”，也就是2个分支交汇于一点的地方。
因为2个分支合并，而产生的不纯祖先，不算数。

 2 详情：git help config  看 branch.<name>.merge
 
branch.<name>.merge
Defines, together with branch.<name>.remote, the upstream branch
for the given branch. It tells git fetch/git pull which branch to
merge and can also affect git push (see push.default). 【 When in
branch <name>, it tells git fetch the default refspec to be marked
for merging in FETCH_HEAD. 】The value is handled like the remote
part of a refspec, and must match a ref which is fetched from the
remote given by "branch.<name>.remote". The merge information is
used by git pull (which at first calls git fetch) to lookup the
default branch for merging. Without this option, git pull defaults
to merge the first refspec fetched. Specify multiple values to get
an octopus merge. If you wish to setup git pull so that it merges
into <name> from another branch in the local repository, you can
point branch.<name>.merge to the desired branch, and use the
special setting .  (a period) for branch.<name>.remote.

 3 git fetch 也是可以做merge操作的 【It tells git fetch/git pull which branch to
merge】 有时间看


37 什么叫做 staged changes 和 unstaged changes
   根据gitg，gitk，git-gui 综合分析，区别应该在于：
  没有搞懂gitg中的  staged changes 和 unstaged changes
  gitk中显示为：local uncommitted changes,not checked in to index
             local changes checked in to index but not committed
  git-gui 显示为 未缓存的改动（需要解决合并冲突） 和已缓存的改动
   
  gitk 基于tk/tcl 由于是官方软件，安装 git 时就会自动安装，不必另行安装。还有我在包管
  理器中安装了git-gui但是不知道怎么打开，没有git-gui这个命令
  后来发现在gitk的file菜单里面有打开git-gui选项。其实启动git-gui的方式是命令行：git gui
  打开后，可以在“版本库”菜单项中选择 “图示分支” 然后就打开了gitk。看来gitk是git-gui的一部分。
  QGit is a git GUI viewer built on Qt/C++. 
  tig： ncurses-based Git repository browser
  This package contains a text-mode interface for the version control system
  Git. It may be used to browse the history and contents of a repository.
The following main features are supported:
 - View revision logs, commit messages, diffstats, diffs, archive trees and
   file contents.
 - Visualize revision graphs.
 - Stage / unstage changes and add untracked files.【这里也提到了stage unstage】
 - Merge files.
 - Cherry-pick commits.

Ncurses 提供字符终端处理库，包括面板和菜单  tig名字很有意思，是git反过来


38 当有修改没有提交时候，不能git checkout  但是可以git checkout -f 

39 当看到类似 Merge branch 'newbox' of vc.cn:ngb/newbox/platform/frameworks/base into newbox
   这种message时候，说明是本地的newbox分支与远程newbox分支做的合并，不同人做的修改。

40 2011-03-07 难道没有注意到吗？frameworks/base用了一次 “黑色 -mirro参数” 后，现在更清晰了，没有了几十个分支，只有清晰的几个“活跃分支”
   其他的死分支（不活跃的）都没有了,在那里也是碍眼。

42 2011-03-10 关于独立分支和跟踪分支
   本地分支分为独立分支和跟踪分支

43 前几天因为 -mirror 参数搞坏了framework/base仓库，后来发现mirror还很有用
   在rootfs的git的时候，就用mirror来删除远程分支。
   git branch -d name 删除本地分支
   git branch -r -d 可以删除远程分支！！！那么这个操作同步到服务器了嘛？不用push吗？
   但是这个只是删除本地的远程分支，有点绕
  
   关于git branch命令的说明：
   With a -d or -D option, <branchname> will be deleted. You may specify more
   than one branch for deletion. If the branch currently has a reflog then
   the reflog will also be deleted.

   Use -r together with -d to delete remote-tracking branches. Note, that it
   only makes sense to delete remote-tracking branches if they no longer
   exist in the remote repository or if git fetch was configured not to fetch
   them again. See also the prune subcommand of git-remote(1) for a way to
   clean up all obsolete remote-tracking branches.

认识在一步一步加深： git branch -v
-v, --verbose
Show sha1 and commit subject line for each head, along with relationship to 
upstream branch (if any). If given twice, print the name of the upstream branch, 
as well.

git branch -vv 可以显示类似如下效果：
* girlf  2c9ce30 [origin/girlf] Test1   方括号里面显示的是对应的上游分支，【当然可以不同名】
  master e28d126 [origin/master] Test2
以前以为靠是否同名决定push的时候跟哪个分支去合并，原来是靠.git/config文件中的这个关系，对应描述为：
[branch "master"]
        remote = origin
        merge = refs/heads/master
[branch "girlf"]
        remote = origin
        merge = refs/heads/girlf

git branch -t
-t, --track
When creating a new branch, set up configuration to mark the start-point branch
 as "upstream" from the new branch. This configuration will tell git to show the
relationship between the two branches in git status and git branch -v. 

git branch -vv 可以显示track关系
git status 可以看到类似
# On branch zhulin
# Your branch is ahead of 'origin/zhulin' by 2 commits. 这里有跟踪关系。

Furthermore, it directs git pull without arguments to pull from the upstream when 
the new branch is checked out.

This behavior is the default when the start point is a remote branch. Set the 
branch.autosetupmerge configuration variable to false if you want git checkout and
git branch to always behave as if --no-track were given. Set it to always if you
 want this behavior when the start-point is either a local or remote branch.

我完全可以这样：git branch gaojie origin/girlf 打印：Branch gaojie set up to track
 remote branch girlf from origin.
说明创建了一个本地分支gaojie，跟远程分支girlf 有跟踪关系！在.git/config中有：
[branch "gaojie"]
   remote = origin
   merge = refs/heads/girlf
可见，完全可以不同名！


Update the remote-tracking branches for the repository you cloned
from, then merge one of them into your current branch:

  $ git pull, git pull origin


$>git branch xxxx origin/girlfrind1 
Branch xxxx set up to track remote branch girlfrind1 from origin.

45 关于 git config

执行git config -l 显示：
branch.newbox.remote=ngb
branch.newbox.merge=refs/heads/newbox
看来这个跟上面2个是对应的。

--global
For writing options: write to global ~/.gitconfig file rather than
the repository .git/config.


If not set explicitly with --file, there are three files where git
config will search for configuration options:

$GIT_DIR/config
Repository specific configuration file. (The filename is of course
relative to the repository root, not the working directory.)

~/.gitconfig
User-specific configuration file. Also called "global"
configuration file.

$(prefix)/etc/gitconfig
System-wide configuration file.

The git configuration file contains a number of variables that affect
the git command’s behavior.

46 还是关于分支
如果在一个本地分支下，git branch name 创建一个分支 就是一个单独分支
而不是跟踪分支。
而如果执行 git branch name origin/name 则会提示：
Branch gaohuinaike set up to track remote branch zhulin from origin.

关于git branch --track 的一个说明
Furthermore, it directs git pull without arguments to pull from the upstream when 
the new branch is checked out.
意思是说，如果一个本地分支跟远程分支有跟踪关系，git pull 不加任何参数，自动会pull远程被跟踪的分支

**git checkout origin/gaojie  会进入 detached HEAD 状态
在这种状态下提交，会提示 [detached HEAD 48b7b98]

48 detached HEAD 就是一个“无头尸”。无头尸只要一坐 git checkout 操作就没有了。
git的逻辑相当严密，代码质量也很高！很间接，可以跟kernel媲美了！
在detached HEAD状态下，可以做合并操作。

49 关于git merge时候的打印信息

50 git-checkout - Checkout a branch or paths to the working tree
不知道这里的paths是什么东西。
【slash斜线 back slash反斜线】
学会一条新命令：git checkout -t origin/gaojie 同样会创建一个本地跟踪分支 gaojie
并切换至！  类似于 git checkout -b  gaojie origin/gaojie


51 error: --all and --mirror are incompatible
   --all --mirror 不能同时用

52 通过实验得出结论：在.git/config中没有写跟踪关系的，只要是同名分支，也有跟踪关系。
[2011-03-13终于找到依据]
git help config 找到 push.default 

push.default
Defines the action git push should take if no refspec is given
on the command line, no refspec is configured in the remote, and
no refspec is implied by any of the options given on the command
line. Possible values are:

nothing do not push anything.

matching push all matching branches. All branches having
the same name in both ends are considered to be matching.
This is the default.【*注意*这里也说明只有同名认为是match】

tracking push the current branch to its upstream branch.
current push the current branch to a branch of the same name.

实践也证明，git push 无参数的时候，只认同名，不认什么track关系。

git config push.default nothing
会在.git/config 里面添加
[push]
	default = nothing
这个时候就不能做push的操作了，会提示错误。

设置成 git config push.default tracking 就有意思了：
推送当前分支到跟踪分支，这时候，即使不同名的tracking分支也会被推送
如果此时，当前分支没有跟踪关系，git push 则会提示：
The current branch <name> is not tracking anything.

53 所谓的tracking关系，也只是在本地，服务端没有什么跟踪关系。

54 最新结论，不同名的track分支，很麻烦，所以一定要同名
git checkout -b  gaohui  origin/gaojie  创建不同名track关系分支
git commit 后  ，git push推不上去。git push origin gaohui 又会在远程创建一个
gaohui分支，git push --all 也会在远程创建一个gaohui新分支。

那么怎么才能把不同名的track分支push上去呢？
复杂啊！ 看看branch.<name>.remote

54  关于我一直没有想明白的那个问题，我做了个实验
当有2个分支同时更新时，git pull 只合并当前分支，其他分支只fetch回来，并不合并
看看fetch的help吧：
DESCRIPTION
Runs git fetch with the given parameters, and calls git merge to merge the 
retrieved head(s) into the current branch. With --rebase, calls git rebase instead 
of git merge.

如果当前所在的分支没有描述跟踪分支，则在git pull的时候，会提示：



55 注意：merge必须是合并到当前分支，不可以在当前分支去合并另外2个分支
比如在非master分支，执行 git merge master origin/master
想把远程master分支跟本地master分支合并，被认为是把2个分支合并到当前分支
Merge branches fixes and enhancements on top of the current branch, making an octopus merge:
 $ git merge fixes enhancements

56 我需要重新认识git pull命令了
我在yumen这个本地分支，执行
git pull origin master  竟然可以把master分支合并到郁闷分支。
当然这种操作已经没有任何意义了！！！！！！！！！！！！
git push origin master 命令可以在非master分支把master分支推送上去。

57 FETCH_HEAD 是？

58 第一次在gitg中看到 “stash”贮藏  标签。不知怎么出来的。
 git-stash - Stash the changes in a dirty working directory away


git stash：在第一篇中，我举了一个使用branch解决紧急任务切换的问题，其实stash命令
也可以很好的解决这样的问题。当你不想提交当前完成了一半的代码，但是却不得不修改一个紧
急Bug，那么使用'git stash'就可以将你当前未提交到本地(和服务器)的代码推入到Git的栈中，
这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug，等到修完Bug，
提交到服务器上后，再使用'git stash apply'将以前一半的工作应用回来。也许有的人会说，
那我可不可以多次将未提交的代码压入到栈中?答案是可以的。当你多次使用'git stash'命令后，
你的栈里将充满了未提交的代码，这时候你会对将哪个版本应用回来有些困惑，'git stash list'
命令可以将当前的Git栈信息打印出来，你只需要将找到对应的版本号，例如使用'git stash 
apply stash@{1}'就可以将你指定版本号为stash@{1}的工作取出来，当你将所有的栈都应用回
来的时候，可以使用'git stash clear'来将栈清空
“git stash clear”


61 关于git clone --bare  --mirror 参数
用bionic实验，发现 --bare 与 --mirror 下来的仓库都是没有检出的 bionic.git 
唯一的区别是config文件不同
mirror的多了一行 [remote "origin"]
	fetch = +refs/*:refs/*
	mirror = true
	url = git@vc.cn:ngb/newbox/platform/bionic.git


发现一个怪现象 现在的bionic仓库 git clone 下来后就有一个base_platfor_r2.3-r1 这个本地分支
那么为什么这个分支就会自动创建一个本地分支呢？而不用我在本地创建这个本地分支。


62 2011-04-20 再次考察repo用法
   今天开始弄gingerbread，那么如何从原来的froyo切换到gingerbread呢？
   直接把manifest仓库切换到gingerbread 再执行repo sync 不行  提示：
   .repo/manifests/: discarding 9 commits
需要现执行 ./repo init -u git@vc.cn:ngb/newbox/manifest.git  -b gingerbread
然后 ./repo sync  成功！

但是最后也出现异常提示：
  First, rewinding head to replay your work on top of it...
Applying: 增加NXP SDK2.0 中对openmax的支持
说明再 同步的时候，对没有push的服务器的分支，repo 做了 rebase的操作！！？？
有必要吗？
The 'repo sync' command synchronizes local project directories with the
remote repositories specified in the manifest. If a local project does
not yet exist, it will clone a new local directory from the remote
repository and set up tracking branches as specified in the manifest. If
the local project already exists, 'repo sync' will update the remote
branches and rebase any new local changes on top of the new remote
changes.【 这里的rebase操作是在让我无法理解 无法理解真是！！为什么要rebase呢?20110421】


'repo sync' will synchronize all projects listed at the command line.
Projects can be specified either by name, or by a relative or absolute
path to the project's local directory. If no projects are specified,
'repo sync' will synchronize all projects listed in the manifest.

The -d/--detach option can be used to switch specified projects back to
the manifest revision. This option is especially helpful if the project
is currently on a topic branch, but the manifest revision is temporarily
needed.

The -s/--smart-sync option can be used to sync to a known good build as
specified by the manifest-server element in the current manifest.

The -f/--force-broken option can be used to proceed with syncing other
projects if a project sync fails.

  -l, --local-only      only update working tree, don't fetch
  -n, --network-only    fetch only, don't update working tree
更新working tree 是什么意思，就是checkout吗？   应该就是checkout 因为每次打印
Syncing work tree 后面都跟着我再checkout里面加的打印。

bootable/recovery/: discarding 17 commits 这是什么意思

最后重新开始下载，最后打印：
Checking out files: 100% (8808/8808), done.ut files:   3% (317/8808)   
Checking out files: 100% (4679/4679), done.out files:  37% (1734/4679)   
Checking out files: 100% (94/94), done.ing out files:   9% (9/94)   
Checking out files: 100% (10008/10008), done.t files:  27% (2802/10008)   
Checking out files: 100% (11471/11471), done.t files:   9% (1092/11471)   
Checking out files: 100% (7241/7241), done. out files:   0% (56/7241)   
Syncing work tree: 100% (165/165), done.  


63 2011-04-20 关于git服务器的管理
   他说：产品分支 只能由他们組合并，其他人没有权限合并提交代码。 也就是说可以对单独分支设置权限。

64 生成froyo-20100729.xml的方法
  repo manifest -o xx.xml -r   
  -r 表示生成提交号  否则就是把原来的manifest复制一份。

65 Syncing work tree ^_^ 是在repo里面显示的

66 git-rebase  只是一个脚本 还有git-rebase.sh
   今天发现，执行rebase命令后，原来的分支自动消失，并不向我跟姚军说的那样，再需要手动删除原来的分支。
  执行rebase命令的时候，就会打印 First, rewinding head to replay your work on top of it...
67 repo  也有 rebase 命令
  help：  Rebase local branches on upstream branch 什么意思？

'repo rebase' uses git rebase to move local changes in the current topic branch to the HEAD of the 
upstream history, useful when you have made commits in a topic branch but need to incorporate new 
upstream changes "underneath" them.  不明白啊

68 删除一个分支的方法：利用push命令 <refspec> 
   git push ngb :test  就可以删除远程的test分支，这表明  +<src>:<des>  冒号前为空，就删除了远程分支
其实，在git help push 中有:Pushing an empty <src> allows you to delete the <dst> ref from the remote repository.
   也可以用这种方式git push ngb test:gao 在远端生成 另外一个名字的分支 但是这样的话，【这两个分支就没有关联性了吧】

只执行 git push的时候  如果本地，远程 分支名不同，且没有track关系，提示
fatal: No destination configured to push to.
如果有 track 关系 也提交不上去，但是打印不同  [看看build-push.c的源码就会明白]
【 默认，git push 推送同名分支  但是可以设置成推送track分支，靠push.default字段(难道这个push.default就是指没有任何参数的git push吗？) 】

[20110421]push帮助中的 EXAMPLES有很多经典情况，仔细看：
【关于 “+” 的用法：复杂！！2011-04-21】
The object referenced by <src> is used to update the <dst> reference on the remote side, but by default this is only allowed if the update can fast-forward
<dst>. By having the optional leading +, you can tell git to update the <dst> ref even when the update is not a fast-forward. This does not attempt to merge
<src> into <dst>. See EXAMPLES below for details.
“+”号，不做fast forword 但是也不合并，注意看git help push 的例子，是用一个分支替换另一个分支
被替换的分支变成不可以访问的无名分支，可以用 git gc 清除 


static int do_push(const char *repo, int flags)
{
        int i, errs;
        struct remote *remote = remote_get(repo);
        const char **url;
        int url_nr;

        if (!remote) {
                if (repo)
                        die("bad repository '%s'", repo);
                die("No destination configured to push to.");
        }
...
}

git push ngb test:gao  冒号前后不能又空格

69 2011-04-21
   使用repo系统在froyo和gingerbread之间切换有一个 rebase的问题。暂时先整个重新同步吧
   为什么要rebase呢？奇怪！有时间再说吧！呵呵

70 manifest.git中为什么没有gingerbread-release 分支，那么每个仓库中的gingerbread-release分支怎么搞出来啊

71 2011-05-07 关于SDK git仓库的维护
   为了维护u-boot  我单独分了一个分支，u-boot比较独立但是跟整个sdk是一个分支，所以有一个原则：一般不要向u-boot这个分支合并代码，而是u-boot向fawn合并代码。


72 关于git分支模型在ngb项目中的应用的深入思考
关于一个git 模型：
姬总提出，采用增量式集成。发布一个版本的时候，要保证绝对稳定，然后才可以继续继承其他模块。
那么在git使用上，把模型简化就是：版本1发布，开测，然后所有人停止工作等待bug，n天后bug解差不多，认为稳定（“稳定”也是有标准的）
大家再开始工作，以后以此类推。显然这样是不行的。
那通过讨论，我想出第二个模型。
后来使用了git，在封闭阶段，大家都有权限提交代码。因为git的灵魂是分支。当时这种用法觉得也行。但是后来发现代码的质量真的控制不住。因为没有了review的过程。

现在在git上加入review服务器，就达到了兼顾的效果，既有review，又有自动合并。比之原来svn的模式，手工合并代码，一个人review（因为没有网络，分布式的环境）


73 模型：5分钟：此次升级工作，姬总提出，一个基础版本合并一定的功能，经过严格测试，保证稳定后才可以再合并新功能，一次类推
   但是如果在git体现出来这个过程有一定困难。我提出了一个网络拓展模型：
   git有2条线，发布线和开发线。发布一个版本提交测试，同时开发线向前生长，发布线修改bug。测试认为稳定了合并开发线以后以此类推。如果后来又发现某一个向发布线提交的代码有bug
   就在那个提交处生长出fix bug的提交。回归测试（回到只有某些功能的那个版本处）后若没有问题再合并至最新版本。这样想的是很完美，但是实际上没有太大的作用。好处就是可以得到
   没有“某些功能”但是有“完善的”“某些功能”的版本。得到这个版本是为了查问题。查比较“怪异”的问题。
   如果不这样做，到后期真的需要这样的版本，只能手动生成这样的版本。这样做呢,维护起来又太复杂。得失之间，难于取舍。最终决定不这样做,之维护一条线。“针对第一次发布测出来的bug要在第二次提交版本的时候”

74 (20120605)bin文件冲突
a. 执行merge动作后 冲突提示：Automatic merge failed; fix conflicts and then commit the result.手动决定使用哪个bin，直接提交即可。
b. error: Your local changes to the following files would be overwritten by merge:

75 (20110616)时至今日，我还不是不知道怎样用命令行方式建立一个跟远程分支有track关系的本地分支（当然可以在gitg上用鼠标完成）

76 (20110617)今天第一次使用了git cherry-pick 命令，挺好用。事情经过：
   trident的SDK3.0 SDK3.0.1 有复杂弱智的冲突。结果在合并的时候出现了问题。先是在3.0上打了一个filter的补丁，后来发布了3.0.1有没有打这个补丁，但是在其他部分做了修改，结果merge的时候出现了问题。
   具体点：关于filter的一个文件，先是加了一行，后来又被删除了，现在想再加回来只需要执行git gerry-pick hash号 即可。
   突然想到，gerry-pick这个命令是很好的。比如  （3.0）-（3.0.1）-（smartcard fix） 现在我想要一个在3.0基础上更新smartcard的版本，只需要在3.0那个提交上git gerry-pick （smartcard fix）


76  20110621 git revert  用于恢复一个提交 相当于undo

77 (20110701) git-stash - Stash the changes in a dirty working directory away
修改了git工程文件但是没有提交，在gitg中用鼠标在远程分支上建立本地分支，gitg会自动执行stash，并自动加注释
gitg auto stash: HEAD: 692aa7f Merge "@0002740: 增加Mute键值" into fawn
后面的注释是在修改的时候 git最后一次提交的状态。这之后不排除执行了fetch之类的命令使得HEAD生长。


78 (20110720) git fetch origin fawn  
   如何 fetch 一个仓库的一个分支！？

79 由于使用 .gitignore 不当，使得git merge 不能成功，又不知道怎么修改。文件上传后再修改 .gitignore 容易出现错误。
   并且，如果一个文件已经被git系统 add  再添加到 .gitignore 将不起作用！！！！


target/src/sd/standby/drivers/comps/tmscsScd/src/tmscsSc_Firmware.c
target/src/sd/standby/firmware/comps/tmscsScf_Drivers/comps/tmscsScfIrrx/lib/armgnu_nullos_el_cortex-m3/summit-singlehd_license_free/libtmscsScfIrrx.a

80 (20110802) git用了这么久了，还是会遇到很多问题，很有意思
   场景：在分支A处创建新分支B，在B分支上删除一个文件，在分支A上做一次普通修改，然后把B分支合并到A分支，会出现如下打印：

  fatal: 'merge' is not possible because you have unmerged files.
  Please, fix them up in the work tree, and then use 'git add/rm <file>' as
  appropriate to mark resolution and make a commit, or use 'git commit -a'.

也就是说不能靠合并的方式 增加/删除文件。
不对，又测试了一下，合并是可以删除文件，也可以添加文件 。比如在一个分支上删除一个文件，合并到另外一个分支，这个文件就会被删除！
想起来了，上面那个测试，删除的文件和另外一个分支修改的文件是同一个文件，所以提示 'merge' is not possible 
又删除，又修改，这就是冲突。

其实，添加删除文件， 文件改变路径，都可以合并。刚才建勇fuse.ko改变位置，合并打印
error: Untracked working tree file 'opt/lib/modules/2.6.34/other/fuse/fuse.ko' would be overwritten by merge.  Aborting
是其他原因，不知道怎么的，在当前分支出现了fuse/fuse.ko 但是这个文件还没有被当前分支跟踪（track） 所以不能合并带有这个文件的分支，至于这个文件是怎么出来的就不得而知了 呵呵。

81 20111104 昨天晚上去中国建筑科学研究院讲git课程


82 20111206 搭建git服务器

首先建立一个bare 没有工作目录的仓库

android的那种 git 链接的效果是怎么做出来的？

manifest.xml 里面用 name path version 描述一个仓库


83 20111213
建立海思git仓库， 比如bionic.git 需要先在本地执行 git init --bare 再传给管理员吗？
repo init -u  给出manifest地址   这个过程会完成 manifest 和 repo两个仓库的下载。

今天第一次在服务器上建立空仓库。空仓库（git init --bare）拷贝到服务器后，本地clone 然后git add  git commit  git push origin（这个名字tab建自动出来） master 

1 建立 repo仓库
2 建立manifest仓库 因为repo首先下载这2个仓库  manifest仓库简单说就是一个 default.xml文件

default.xml 里面 <remote  name="vc"  这里的name决定了以后gitg查看分支时候显示的组


83 20111214 在.git目录中也可以gitg

84 
'-u', '--manifest-url
'-b', '--manifest-branch'
'-m', '--manifest-name'


85 如果误将某个要ignore的文件提交，可以先将他加入 .gitignore 再删除这个文件再提交。不必重建仓库


86 另外一个分布式版本控制器 mercurial  sdl用这个维护的 python编写

87 
20120109
apk仓库迁移, 手机遥控器，voip 保留修改历史的迁移。其实，用于服务器的 git init --bare 的仓库与本地下载下来的区别只在于 config 文件 bare的只有：

[core]
	repositoryformatversion = 0
	filemode = true
	bare = true

然后在ref/heads/里面要建立 master 文件【很重要】

并且，没有refs/remotes (这点 我有点疑惑，如果服务器的这个仓库又基于一个远程仓库呢？比如google的仓库，2010年我想过这个问题，:-)先不管了)

88 
20120116
在海思仓android源码仓库维护的时候，webkit目前无法做到所有项目一致，那么就要在webkit仓库上建立项目分支。以前（trident）的做法是，在所有仓库上建立一个分支。
实际上多数仓库都是一致的，可以通过manifest仓库，只把特定仓库建立项目分支即可。实验证明：

<?xml version="1.0" encoding="UTF-8"?>
<manifest>
  <remote  name="Hisi" fetch="ssh://192.168.1.4:29418/HiAndroid/" />
  <default revision="master" remote="Hisi" />
  <project path="bionic" name="platform/bionic" />
  <project path="external_ccdt/webkit" name="platform/external_ccdt/webkit" revision="ccdt_extend"/> /*注意这里，单独指定仓库分支*/
</manifest>

这种维护方式，思路比较清晰了！

manifest里面的xml 里面删除了某个仓库，./repo sync 就会把这个仓库删除


89
2 repo 是一个physon 脚本
执行后，先用 
git init  
git config  设定仓库地址
git fetch 
的方法获得 repo.git仓库  这个方法等价于  git clone

我可以直接执行：
git clone  git://android.git.kernel.org/tools/repo.git 打印
Initialized empty Git repository in /home/gaojie/Backup/GingerBread/untitled folder/repo/.git/
可见，clone 也要先初始化仓库  

git clone = git init + git config + git fetch +（git update-ref + symbolic-ref + read-tree ） 括号里等价于 fetch

repo为什么要这样做呢？

在fetch 后 执行 git checkout  origin/master 打印
You are in 'detached HEAD' state.  但是可以把检出

git branch 会显示 （no branch）


./repo help init

Summary
-------
Initialize repo in the current directory

Usage: repo init [options]

Options:
  -h, --help            show this help message and exit

  Logging options:
    -q, --quiet         be quiet

  Manifest options:
    -u URL, --manifest-url=URL
                        manifest repository location
    -b REVISION, --manifest-branch=REVISION
                        manifest branch or revision
    -m NAME.xml, --manifest-name=NAME.xml
                        initial manifest file
    --mirror            mirror the forrest
    --reference=DIR     location of mirror directory

./repo -u  -b 后面可以加 revision 也就是一次提交

运行 repo init 后，下载了2个仓库：repo.git 和 manifest.git

project.py 竟然有初始化 git目录的代码，自己建立  manifest.git文件夹

repo仓库 是用git init 简历出来的 所以repo仓库很普通 在repo目录下有一个 .git 目录


manifest仓库的结构跟其他工程的仓库一样：
manifest目录下有一个.git目录 但是这个目录下的文件/夹 基本是链接，链接到manifest.git目录中

最终用的还是 init fetch 这些命令  没有直接使用 clone   clone 可能无法做到 .git在不同位置吧 呵呵


_InitGitDir 靠这个函数创建的 git基本目录



./project.py:  def Sync_NetworkHalf(self, quiet=False):
这个函数在这里定义 2此调用，依次为：
./subcmds/init.py:    if not m.Sync_NetworkHalf():
这里是在同步 manifest.git
./subcmds/sync.py:      mp.Sync_NetworkHalf(quiet=opt.quiet)
这里是同步其他150多个仓库


90
git diff很强大,真的很强大.比较任何两个历史版本,速度飞快. 
git svn 命令 竟然也是能用的  git太强大了
我首次享受到了 Git的Fork和Merge的乐趣。   git fork ???

有趣的是,Linus当时设计git的时候,说:"...当碰到一个特性不确定应该采取什么样的设计时,就
只要照着svn的反方向设计就对了..." [这也太损了!]


在gitg上看，是绿色标签，表示本地分支 可以在gitg上 右击创建 标签，分支等
出现在一行，显示2个绿色标签

push的时候本地与服务器的名字不需要相同

3 在android git网站上
commit	ba74b3854ac9bfb6c850498a4581753c98c09dd7
tree	babbb1a64e25a4ce0ba42a85f55060eb8e90c998	tree | snapshot  tree的版本是什么意思？
parent	218ebce02f691921fa7bcc9264abfb047f50e1dd

gitg上显示的时间，是本地提交的时间，不是push到服务器的时间。

同样是froyo这个分支，也在不停的向前生长，

理解了 冲突产生的原因，还需要进一步测试


我们的 RSA 指纹码是 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48  ??指纹？

Unless this is your first time setting up ssh or git on your computer, you should 
double check that keys do not already exist. If they do you can either use the 
existing key(s) or remove them. In either case, you should make a backup of the 
keys.

If you have an existing keypair you wish to use, you can skip this step.
看来，如果以前有过配对，就直接使用即可


git remote add origin git@github.com:gaojie/Test-repo2.git  ？？？

git remote add <name> <url>
  adds a remote named <name> for the repository at <url>  给远程的仓库添加一个名字

The command git fetch <name> can then be used to create and update
remote-tracking branches <name>/<branch>.  origin/master

With -m <master> option, $GIT_DIR/remotes/<name>/HEAD is set up to
point at remote’s <master> branch. See also the set-head command.

In mirror mode, enabled with --mirror, the refs will not be stored
in the refs/remotes/ namespace, but in refs/heads/.

git remote add <name> <url>  

git remote add Gaojie  git@github.com:gaojie/Test-repo2.git  给这个仓库取一个名字
git push Gaojie  master  把master 分支 push 到Gaojie仓库上去

       Start development from a known tag

               $ git clone git://git.kernel.org/pub/scm/.../linux-2.6 my2.6
               $ cd my2.6
               $ git branch my2.6.14 v2.6.14   (1)
               $ git checkout my2.6.14

           1. This step and the next one could be combined into a single step
           with "checkout -b my2.6.14 v2.6.14".

git help中的格式 有[]  ()  <> 都是什么含义啊？

git branch [--set-upstream | --track | --no-track] [-l] [-f] <branchname> [<start-point>] 
-f  --force
    Reset <branchname> to <startpoint> if <branchname> exists already. Without -f git branch refuses to change an existing branch.
方括号表示可选

[<start-point>]  可以指定一个标签 一个SHA号码  也可以不指定 默认当前分支的头部

git branch Hello V1.0  当前分支的V1.0标签处 创建一个分支 Hello

git-checkout - Checkout a branch or paths to the working tree  路径是啥东西？

git checkout [-q] [-f] [-m] [<branch>]  可以不加任何参数？
git checkout [-q] [-f] [-m] [-b <new_branch>] [<start_point>]  -b 可以创建新的branch 跟 git branch 一样 同时checkout到这个新分支

<start_point>
The name of a commit at which to start the new branch; see git-branch(1) for details. Defaults to HEAD.默认是头

git log  什么参数都不加的时候，只显示 当前branch 线上的log信息


git branch  World 
fatal: A branch named 'World' already exists. 已经存在的分支名字，不能再次创建

冲突，跟“共同点”对比，而不是我想的，只要找到一个“基点”就可以。

git merge World  把World分支合并到当前分支


git merge <msg> HEAD <commit>...  意思是可以只写一个分支头的名字
                  A---B---C topic
                    /
               D---E---F---G master

git merge topic
                  A---B---C topic
                    /         \
               D---E---F---G---H master

DESCRIPTION
       Incorporates changes from the named commits (since the time their histories diverged from the current branch)
       into the current branch. This command is used by git pull to incorporate changes from another repository and
       can be used by hand to merge changes from one branch into another.

       Assume the following history exists and the current branch is "master":

                     A---B---C topic
                    /
               D---E---F---G master

       Then "git merge topic" will replay the changes made on the topic branch since it diverged from master (i.e.,
       E) until its current commit (C) on top of master, and record the result in a new commit along with the names
       of the two parent commits and a log message from the user describing the changes.

                     A---B---C topic
                    /         \
               D---E---F---G---H master

       The second syntax (<msg> HEAD <commit>...) is supported for historical reasons. Do not use it from the command
       line or in new scripts. It is the same as git merge -m <msg> <commit>....

       Warning: Running git merge with uncommitted changes is discouraged: while possible, it leaves you in a state
       that is hard to back out of in the case of a conflict.


If you tried a merge which resulted in complex conflicts and want to start over, you can recover with git
reset --merge.

git help reset 
       --merge
           Resets the index to match the tree recorded by the named commit, and updates the files that are different
           between the named commit and the current commit in the working tree.

 git reset --merge  恢复合并之前的代码
 git reset 6182207e3a3dfc572251ed54a2587faa01726277 会产生 没有提交的代码 就是说版本库回去了但代码还是改过的
 git reset --hard 6182207e3a3dfc572251ed54a2587faa01726277  同时代码也恢复


       An alternative style can be used by setting the "merge.conflictstyle" configuration variable to "diff3". In
       "diff3" style, the above conflict may look like this:


HOW TO RESOLVE CONFLICTS
       After seeing a conflict, you can do two things:

       ·   Decide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit to reverse
           2. and to clean up working tree changes made by 2. and 3.; git-reset --hard can be used for this.

       ·   Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git
           add them to the index. Use git commit to seal the deal.
解决冲突的方法很简单：直接编辑加了标识的文件，然后提交 。解决了所有冲突后 git commit -a 此时vim中自动显示： 
Merge xxx  conflicts: xx 当然，带标识的文件一样可以提交，但是这个文件就没有任何意义了。

       You can work through the conflict with a number of tools:

       ·   Use a mergetool.  git mergetool to launch a graphical mergetool which will work you through the merge.

       ·   Look at the diffs.  git diff will show a three-way diff, highlighting changes from both the HEAD and
           MERGE_HEAD versions.

       ·   Look at the diffs from each branch.  git log --merge -p <path> will show diffs first for the HEAD version
           and then the MERGE_HEAD version.

       ·   Look at the originals.  git show :1:filename shows the common ancestor, git show :2:filename shows the
           HEAD version, and git show :3:filename shows the MERGE_HEAD version.


git branch -d 删除一个分支 
 Delete a branch. The branch must be fully merged in HEAD.
而 HEAD 指的是 ref: refs/heads/master 【错，当前是哪个分支，这里就是哪个分支】
$ git branch -d World 
Deleted branch World (was 94aac85).
合并到当前分支后，就可以删除这个分支了 94aac85 是被删除分支头的号码
但是只是World 这个分支的名字没有了， 这个分支上的提交还有
-D  也是同样，把分支名字删除了，但是提交点还在

我一直不明白的合并方式，合并操作的打印信息不同的：
普通合并操作：
Auto-merging blkdev.h
Merge made by recursive.
 blkdev.h |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

而不明白的那种的提示是
Updating 98a954c..f0e5342   这两个数字是master 从原始位置推进到 的位置
Fast-forward  快进的意思
 blkdev.h |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

merge命令里面有 --ff  代表 fast forward


git-diff - Show changes between commits, commit and working tree, etc


FAST-FORWARD MERGE
       Often the current branch head is an ancestor of the named commit. This is the most common
       case especially when invoked from git pull: you are tracking an upstream repository, you have
       committed no local changes, and now you want to update to a newer upstream revision. In this
       case, a new commit is not needed to store the combined history; instead, the HEAD (along with
       the index) is updated to point at the named commit, without creating an extra merge commit.
       This behavior can be suppressed with the --no-ff option.
我靠，这里有详细说明
当前的branch头是某个提交的祖先，


Except in a fast-forward merge (see above), the branches to be merged must be tied together
by a merge commit that has both of them as its parents.
除了 fast-forward 合并，看来这种合并是比较特殊的。


对于不可能fast-forward形式合并的情况执行
gaojie@gaojie:~/NXP/TestGitHub/repo2$ git merge --ff-only xiaoniu 
fatal: Not possible to fast-forward, aborting.
gaojie@gaojie:~/NXP/TestGitHub/repo2$ 



注意 git merge 只能把其他分支合并到当前分支
这个打印
在gaohui处简历分支yurongfu 在yurongfu上提交2次 然后执行
git merge gaohui 打印出
Already up-to-date.

git merge gaohui xiaoniu   意思是把另外2个分支合并到 当前分支
git merge --no-ff yurongfu  就是我一开始想象的那个样子了


$ git clone git://github.com/gaojie/Test-repo2.git
执行后发现 本地显示有一个 origin/master  和一个本地 master  【我记得远程仓库名字我改成gaojie了啊？】


git-push - Update remote refs along with associated objects

Updates remote refs using local refs, while sending objects necessary to complete the given refs.

git push 中也有 fast forward 的说明

$ git push git://github.com/gaojie/Test-repo2.git
fatal: remote error: 
  You can't push to git://github.com/gaojie/Test-repo2.git
  Use git@github.com:gaojie/Test-repo2.git

git push git@github.com:gaojie/Test-repo2.git  把当前分支的头 push到服务器

push 上去之后， 本地看不到远程的master 向前走啊
git status 还是显示 
# Your branch is ahead of 'origin/master' by 1 commit.

这个时候重新建立一个仓库，clone 一下，发现远程的master头 在本地也向前走了

执行git fetch --all  不用加远程仓库地址  就可以更新push的内容

fetch      Download objects and refs from another repository


rebase：
                     A---B---C topic
                    /
               D---E---F---G master

       From this point, the result of either of the following commands:

           git rebase master
           git rebase master topic

       would be:

                             A'--B'--C' topic
                            /
               D---E---F---G master

git-fetch - Download objects and refs from another repository
git-pull - Fetch from and merge with another repository or a local branch
本地的分支也可以pull？

objects 和 refs 是两个目录 里面包含很多东西
那么 fetch 和 pull 有什么区别 呢？

git pull 的description
Runs git fetch with the given parameters, and calls git merge to merge the retrieved
head(s) into the current branch. With --rebase, calls git rebase instead of git merge.
也就是说 git pull 是git fetch+git merge或者git rebase

       Note that you can use . (current directory) as the <repository> to pull from the local
       repository — this is useful when merging local branches into the current branch.

       Also note that options meant for git pull itself and underlying git merge must be given
       before the options meant for git fetch.

       Warning: Running git pull (actually, the underlying git merge) with uncommitted changes
       is discouraged: while possible, it leaves you in a state that is hard to back out of in
       the case of a conflict.


OPTIONS
   Options related to merging   注意了：这里传给pull的选项，实际上是传给merge的参数
       --commit, --no-commit
           Perform the merge and commit the result. This option can be used to override
           --no-commit.

           With --no-commit perform the merge but pretend the merge failed and do not
           autocommit, to give the user a chance to inspect and further tweak the merge result
           before committing.

       --ff, --no-ff
           Do not generate a merge commit if the merge resolved as a fast-forward, only update
           the branch pointer. This is the default behavior of git-merge.

           With --no-ff Generate a merge commit even if the merge resolved as a fast-forward.

       --log, --no-log
           In addition to branch names, populate the log message with one-line descriptions from
           the actual commits that are being merged.

           With --no-log do not list one-line descriptions from the actual commits being merged.

也就是说 执行fetch 不产生合并

Options related to fetching  传递给fetch 的选项
       --all
           Fetch all remotes.

checkout 到 origin/master
$ git checkout origin/master 
Note: checking out 'origin/master'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b new_branch_name

HEAD is now at 085038d... Test 3

但是这个时候 git branch 会显示 
* (no branch)
  master

区分 head  HEAD的含义  执行的是fetch 而不是 pull
$ git checkout  master   从远端 fetch 下来一个origin/master  与本地master 没有合并 然后执行
Previous HEAD position was 085038d... Test 3  切换branch 的时候 提示前面的头的位置
Switched to branch 'master'
Your branch and 'origin/master' have diverged,  分歧
and have 1 and 1 different commit(s) each, respectively.

这时候执行 
$ git merge origin/master   把本地master 与origin/master 合并了
再执行
$ git push   必须给一个url 地址  git@github.com:gaojie/Test-repo2.git
在执行
$ git fetch  本地的origin/master 跟新到最头处。

git-push - Update remote refs along with associated objects  更新refs 和 objects

       <repository>
           The "remote" repository that is destination of a push operation.
           This parameter can be either a URL (see the section GIT URLS below)
           or the name of a remote (see the section REMOTES below).

搞明白了 fast-forward的用处了：
2个人使用一个仓库，有时候会出现 fetch 后 origin/master 比本地master 靠前的情况，这个时候只需要这行 git merge  origin/master
就是把本地master  fast-forsard 到origin/master 处


FAST-FORWARD MERGE
       Often the current branch head is an ancestor of the named commit. This is the most common
       case especially when invoked from git pull: you are tracking an upstream repository, you have
       committed no local changes, and now you want to update to a newer upstream revision. In this
       case, a new commit is not needed to store the combined history; instead, the HEAD (along with
       the index) is updated to point at the named commit, without creating an extra merge commit.

git pull 会在本地做一次merge 这个已经确定


想搞一个时间不安顺序排列的情况：gitg 上显示的时间是本地提交的时间。注意，一条线上的点，肯定是按照时间排序的

无法再现，
A仓库修改commit时间0:30 然后push
B仓库修改commit时间0:35 然后pull 则gitg 会把A的commit 插在 B的commit 之前  这个实验结果跟我想的不同啊！
到底按照什么时间排序呢？

android 的为什么就出现gitg 中不按照世家排序的情况呢？

gitg上显示的时间是本地时间 而不是服务器时间的统一时间  是每个人电脑上的时间  那么不过每个人电脑上的时间相差很大有影响吗？
应该没有，提交的相互关系不是靠时间决定的 ，而是SHA号码

android 网站上的时间
多数情况下 这两个时间都是一模一样的
author	Adam Powell <adamp@google.com>
  Fri, 23 Jul 2010 22:49:03 +0000 (15:49 -0700) // 2010-07-23 22:49:03  gitg上显示的时间是这个
committer Adam Powell <adamp@google.com>
  Thu, 5 Aug 2010 22:50:31 +0000 (15:50 -0700)  // 2010-08-05 22:50:31  gitg上按照这个排序
也就是说按照提交时间排序  那么显示的时间又是什么时间呢？总之在本地很难再现
【20120815使用了gerrit后才能出现】

关于push的深入理解
有时候本地建立的分支 push 不上去  这时候  
push -all  + git地址


但是对方的本地分支 refs 过不来，过来的是 origin/xx 蓝色  没有绿色的
但是可以在gitg远程分支标签处右击选择 New loacal branch
也可以选择 remove remote branch

--all
   Instead of naming each ref to push, specifies that all refs under
   refs/heads/ be pushed.

84  20120208
海思 rootfs 仓库。有一次操作 checkout  merge 都不行，提示
error: The following untracked working tree files would be overwritten by checkout:
	system/lib/libdd.so
Please move or remove them before you can switch branches.
Aborting

只因为别人增加了一个 libdd.so 

git checkout -f origin/master 可以，但是merge没有-f选项。
不过git checkout -f origin/maser 后，再checkout master 再git merge origin/master 

从本地 git 仓库中提取某个版本的kernel：

   $ git -archive -v v2.6.18 | (cd ../linux-2.6.18/ && tar xf -)
   -v表示--verbose，注意'v2.6.18'必须是 git -tag -l列出来的tags中的一个。
或者打成tarball:
   $ git -archive -v --format=tar v2.6.24 |bzip2 > ../linux-2.6.24.tar.bz2

3.RC：(Release　Candidate)顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候
选版本。RC版不会再加入新的功能了，主要着重于除错。
（1）RC：(Release　Candidate)
　　Candidate是候选人的意思，用在软件上就是候选版本。Release.Candidate.就是发行候选
版本。和Beta版最大的差别在于Beta阶段会一直加入新的功能，但是到了RC版本，几乎就不会加
入新的功能了，而主要着重于除错.是最终发放给用户的最接近正式版的版本，发行后改正bug就
是正式版了，就是正式版之前的最后一个测试版RC版。是 Release Candidate 的缩写，意思是
发布倒计时，候选版本，，该版本已经完成全部功能并清除大部分的 BUG。到了这个阶段只会除
BUG，不会对软件做任何大的更改。从Alpha到Beta再到是改进先后关系，RC1、RC2是取舍关系。 

85 repo sync 的时候，提示
frameworks/base/: leaving master; does not track upstream
packages/apps/: leaving master; does not track upstream


86 孟瑞：一个已有仓库怎么放到服务器上去？  我在做voip仓库的时候做过一次，这次忘怎么搞了！

87 20120415  repo 更新4.0.3时候，如果.repo/repo有更新会自动fast-forward 并提示

info: Restarting repo with latest version

... A new repo command ( 1.15) is available.
... You should upgrade soon:
cp /home/gaojie/Work/Android/android4.0/.repo/repo/repo /home/gaojie/Work/Android/android4.0/repo

89 20120530
赵毅辉一直对我在海思上主推的分布式仓库管理心存疑虑。认为没有bin文件和源码的严格对应关系。
而我认为这样可以加快出版本的速度。他的疑虑完全没有必要。

90 20120726 cherry-pick命令验证成功，切换到当前分支，git cherry-pick sha码，就可以了

91 可以将本地仓库变成可以放到服务器上的仓库。其实 git init --bare  和  git init 生成的东西比较后发现只有 config 文件不同

92 20120815 在维护rootfs时候，发现很久以前，周清辉把master分支合并到baoding分支了，这种操作怎么恢复呢？
Merge branch 'master' of ssh://192.168.1.4:29418/BCM7231/BCM7231-Rootfs into baoding 这种操作我怎么限制呢？

93 分支后，一个分支上删除一个文件，另一个分支上修改了这个文件，合并会产生冲突。
misc：
每个tree 还有一个SHA 号
git支持软链接文件
https://android-review.googlesource.com/#/q/status:open,n,z   google的review服务器地址

94 git图片是怎么加上去的啊！

95 git log -p core/combo/arch/mips/mips32.mk  查这个文件是什么时候被修改的

96 新装git，在[core] 字段添加 editor = vim 改变编译器 可以在 ～/ 下建立 .gitconfig 文件

97 revert命令实战：某3次提交修改了2.0接口，后需要去掉。
这时要从上向下依次执行revert（注意，从下向上会产生冲突，因为3次提交都改了同一个文件）
经验： 1 这个操作能否完美解决问题，跟提交的颗粒度有关，如果某次提交 修改了1个半问题，就不好恢复了。
       2 不能打开创建远程分支的权限，否则对git理解不到位，容易产生分支泛滥。（因为想着再建一个分支，把有用的提交cherry-pick过来）
 
98  2.7版本无法提交tag  （git push --tags） 加了 tag提交权限也不行。查阅：
Previously only "Push Annotated Tag" rights were required to create tags, currently one needs to have "Create Reference" rights as well
必须开 Create Reference 权限。

100  repo 批量打标签命令：
./repo  forall -c git tag timehold-20140319
./repo  forall -c git tag -d timehold-20140319

./repo forall -c git push am8726 --tags (需要加上仓库名 am8726)

101 gerrit2.7  删除tag失败。
git push --mirror
remote: You need 'Push' rights with the 'Force Push'

或者用 
git push origin :refs/tags/testxxx
remote: Processing changes: refs: 1, done    
To ssh://gaojie@192.168.7.32:29418/CDN/scheduler
 - [deleted]         testxxx

需要在Push权限处勾选Force Push 开关

git push origin :refs/tags/gaojie

102 强制删除远程分支
git push origin :refs/heads/itvision-1.2.0-stb-eng  也需要 force push 权限
需要把我加入的相应组中，不加的话，管理员也不灵。

git push origin master --force
git push origin HEAD  --force 强制删除远程某次提交

场景：某次提交已经推送到服务器，发现注释不好，用--amend 修改注释，然后git push origin master --force 可以删除远程的那次错误提交。

reflog命令，相当于垃圾箱

出现error: Exited sync due to gc errors错误
原因： repo 升级，不兼容GIT  1.7.2 以下的版本。
方案升级git到 1.7.2以及以上的版本。
升级方法：
增加ppa 
sudo apt-add-repository ppa:git-core/ppa 
sudo apt-get update 
sudo apt-get install git 
如果本地已经安装过Git，可以使用升级命令： 
sudo apt-get dist-upgrade

------
android大仓库中切换版本：
repo forall -c git checkou xxtag

